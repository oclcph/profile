---
title: 复习
abstract: 计组知识点整理，包含习题
category: 计算机组成原理
---

# Review

## CPU

若 $CPI_i$ 表示 $i$ 类型指令所需要的时钟周期数， $I_i$ 表示 $i$ 类型指令的个数，那么执行整个程序所需要的时间为：

$$
T=I_c\times CPI\times t
$$

其中$I_c=\sum_{i=1}^nI_i$（指令的总数）, $CPI = \frac{\sum_{i=1}^n(CPI_i\times I_i)}{I_c}$（每个指令平均需要的时钟周期数）

**每秒百万条指令**：$MIPS=\frac{I_c}{T\times 10^6}=\frac{f}{CPI\times 10^6}$

**每秒百万条浮点操作**：$MFLOPS=\frac{N_{floating-point\ op}}{T\times 10^6}$，

> $x$MIPS表示1s内计算机可以执行的操作数为$x \times 10^6$，$x$MFLOPS表示1s内计算机可以执行的浮点操作为$x\times 10^6$

**性能限制：**

1. CPU：
   - mos管连线延迟
   - 信号传输延迟
2. 内存：内存与CPU之间的数据传输速度和CPU计算速度相差太大（添加缓存）
3. I/O系统：不同I/O设备处理数据的速度相差太大（缓冲区）

> 1. 控制总线：控制数据线和地址线的访问和使用
> 2. 数据总线：在系统模块之间传送数据
> 3. 地址总线：指定数据总线和地址I/O端口上数据的来源或去向

## 校验码

### 奇偶码

在原数据后增加一位作为检验码。

> 添加后1的个数为奇数，则为**奇校验**，否则为**偶检验**
>
> 对比$C_1、C_2$，若不相同，则证明数据中出错位数为奇数，若相同则证明数据正确或出错位数为偶数

### 海明码：

对原数据进行分成K组，分别计算校验码，得到K位校验码

**步骤：**

1. 根据数据长度计算分组数：若分为K组，原数据长为M，则$2^K\geq 1+M+K$
2. 确定分组
3. 各组内进行按位异或，计算校验码
4. 将前后得到的校验码进行异或，得到出错的索引

### 循环冗余校验

1. 将M位数据左移K位（右侧补0），并用K+1位**生成多项式**除它（**模2**）
2. 采用K位余数作为校验码
3. 把校验码放在数据后面（不含0），一同存储或传输

**纠错：**若M+K位内容可以被多项式除尽，则无错，否则有错

## 机器码转换

### 机器码运算

- 整数加减乘除，浮点数加减（对阶），乘除
- NBCD码，其中`1100`表示正数，`1101`表示负数

> 浮点数计算过后需要进行规格化

**布斯算法**：

**恢复余数除法：**先减去余数，如果差和被除数首位相同，则商1左移，否则不减余数，商0左移。最后根据被除数和除数判断商的符号。

**不恢复余数除法：**

1. 如果**余数**和**除数**符号相同就做减法，否则作加法
2. 如果**差**和**除数**符号相同则商1，否则商0
3. 余数和除数左移
4. 若被除数原长M位，则循环1-3共M次
5. 再多做一次1-2
6. **左移商**，如果商为负，则加1
7. **余数**和**被除数**符号不同，需要修正余数
   1. 如果被除数与除数符号相同，则余数加除数，否则减除数

## 存储器

### 主存

| 存储器类型             | 种类   | 可擦除性           | 写机制 | 易失性 |
| ---------------------- | ------ | ------------------ | ------ | ------ |
| 随机存取存储器RAM      | 读写   | 电可擦除，字节级   | 电     | 易失   |
| 只读存储器ROM          | 只读   | 不可               |        | 非易失 |
| 可编程只读存储器PROM   | 只读   | 不可               | 电     | 非易失 |
| 可擦除PROM(EPROM)      | 主要读 | 紫外线擦除，芯片级 | 电     | 非易失 |
| 电可擦除PROM（EEPROM） | 主要读 | 电，字节级         | 电     | 非易失 |
| 快闪存储器（FLUSH）    | 主要读 | 电，块级           | 电     | 非易失 |

**DRAM：**电容充电，主存

异步：

1. 处理器向内存提供地址和控制信号，表示内存中特定单元的一组数据应该被读出或写入DRAM
2. DRAM执行功能，处理器等待延迟
3. DRAM写入或读取数据

**SDRAM**: 无等待状态，随系统时钟及时移动数据

**SRAM**：电源直连，快，高速缓存

**刷新方式：**

1. 集中式刷新：停止读写操作后刷新每一行，无法操作内存
2. 分散式刷新：在每个存储周期中，读写操作完成时进行刷新
3. 异步刷新：每一行各自以64ms间隔刷新

### 缓存

**平均访问时间：**若p为命中率，$T_C$为cache访问时间，$T_M$为主存访问时间，那么平均访问时间为$T_A=p\times T_C+(1-p)\times (T_C+T_M)=T_C+(1-p)\times T_M$

**映射方式**：实现主存块到cache行的映射

1. 直接映射：将主存中的每个块映射到一个固定可用的Cache行
   1. 若i是Cache行号，j是主存块号，C是Cache行数，则i=j mod C
   2. 标记：地址中最高的n位。**主存地址=标记+Cache行号+块内地址**，用来区分映射到同一行的不同块
   3. 缺点：抖动，两个映射到同一行的块可能会被不断交换
2. 关联映射：主存块可以装入Cache任意一行
   1. 标记：$n=log_2M$，其中M是块数。**主存地址=块号/标记+块内地址**
   2. 缺点：实现复杂，并且检查时需要访问每一行来进行搜索、对比块号
3. 组关联映射：Cache分为若干组，每一组包含相同数量的行，每个块被映射到固定组的任意一行
   1. 若S为组数，M为块数，则$n=log_2M-log_2S$，**主存地址=标记+Cache组号+块内地址**

**替换策略：**

1. 最近最少使用算法，替换掉在cache中**最长时间未被访问**的块
   1. 对于2路组关联映射，每行设置一个USE位。当同一组中的某行被访问时USE位置1，同时另一行置0，替换掉USE位为0的块
2. 先进先出算法，替换掉Cache中**停留时间最长**的块
   1. 时间片轮转法/环形缓冲技术。每行包含标识位，替换标识位为0的行，某行被替换时将其标识位置1，下一行置0
3. 最不经常使用算法，替换掉Cache中访问次数最少的数据块
   1. 每一行设置计数器
4. 随即替换算法，随机替换

**写策略**：主存和Cache一致，当某行Cache被替换时需要判断其中内容是否被修改。若被修改则需要将修改后的数据块写回主存中对应位置

1. 写直达，所有些操作同时对Cache和主存进行
2. 写回法，用一个dirty bit或使用位来标记该处内容是否被修改。如果修改则在下次操作该行时将修改的内容写回

### 外存

#### 磁盘

平均访问时间：$T_a=T_s+\frac{1}{2r}+\frac{b}{rN}$

> $T_s$：寻道时间，$\frac{1}{2r}$：旋转延迟，通常是磁道旋转半周所需时间，b: 传送的字节数，N: 每磁道的字节数，r: 旋转速率（单位：转/秒）
>
> 当连续访问多个相邻磁道时，跨越磁道需要单独考虑旋转延迟，但通常只考虑第一个磁道的寻道时间（明确知道跨越每个磁道所需时间除外）

**磁头寻道算法：**

1. 先来先服务（FCFS）：按照请求访问磁盘的先后次序处理
2. 最短寻道时间优先（SSTF）：优先处理起始位置与当前磁头位置最接近的读写任务

> 可能**饥饿**，即长时间无法处理读写任务

3. 扫描/电梯（SCAN）：总按照一个方向进行调度直到方向边缘，然后改变方向
4. 循环扫面（C-SCAN）：只有磁头朝某个方向移动时才响应请求，移动到边缘后立即返回起点，返回途中不做任何处理

> 比SCAN慢，但各位置磁道的响应频率平均

5. LOOK/C-LOOK：只要磁头移动方向上不再有请求就改变移动方向

#### 磁盘冗余阵列

| 种类   | 描述                                                                                                  |
| ------ | ----------------------------------------------------------------------------------------------------- |
| RAID 0 | 数据以条带的形式在可用的磁盘上分布，用于高数据传输率和高速响应I/O请求。**没有冗余存储**，即无数据保护 |
| RAID 1 | 数据条带，简单备份所有数据实现冗余，即两组硬盘                                                        |
| RAID 2 | 并行存取，使得**所有**磁盘参与**每个**I/O请求的执行，**位级**校验                                     |
| RAID 3 | 并行存取，使得**所有**磁盘参与**每个**I/O请求的执行，**字节级**校验                                   |
| RAID 4 | 并行存取，使得**所有**磁盘参与**每个**I/O请求的执行，**块级**校验                                     |
| RAID 5 | 并行存取，使得**所有**磁盘参与**每个**I/O请求的执行，**块级**校验，每个磁盘上都分布有校验码           |
| RAID 6 | 并行存取，使得**所有**磁盘参与**每个**I/O请求的执行，**块级**校验，每个磁盘上都使用两种校验码         |

### 虚存

#### 分页式虚存

**分页方式**：把主存分成定长的存储块，为**页框**；每个任务被划分为定长的程序块，为**页**，把页装入页框（页框未必连续）

**快表：**存储在联想存储器中的页表部分，存取速度远高于主存。先查快表，再查主存，提高效率。

**地址转换：**虚拟地址=页号+页内偏移

#### 分段式虚存

将程序分成长度不同的段后加载到主存

**虚拟地址=段号+段内偏移**

#### 段页式虚存

将程序和数据分段，再在段中分页，每个分段都有一个页表

虚拟地址=段号+页号+页内偏移量

## 控制

### 寻址方式

#### 普通寻址

| 寻址方式       | 解释                                                                                                      |
| -------------- | --------------------------------------------------------------------------------------------------------- |
| 立即寻址       | 操作数直接出现在指令中，立即数                                                                            |
| 直接寻址       | $EA=A$，地址字段含有操作数的有效地址。根据给出的地址字段可以直接去存储器的相应位置取出数据                |
| 间接寻址       | $EA=(A)$，根据给出的地址字段指示一个存储器的字地址，这个地址中保存有操作数的全长度地址，需要访问2次存储器 |
| 寄存器寻址     | $EA=R$，地址字段直接指示一个寄存器，取出寄存器中的数据                                                    |
| 寄存器间接寻址 | $EA=(R)$，地址字段指示一个寄存器，寄存器中存储的是一个地址，可以根据此地址去存储器中取出数据              |

#### 偏移寻址

$EA=(R)+A$，结合直接寻址和寄存器间接寻址

| 偏移寻址方式   | 解释                                                                                                   |
| -------------- | ------------------------------------------------------------------------------------------------------ |
| 相对寻址       | $EA=(PC)+A$，当前指令的下一条指令的地址加上地址字段的值产生有效地址                                    |
| 基址寄存器寻址 | $EA=(B)+A$，被引用的寄存器含有一个存储器地址，地址字段含有一个相对于该地址的偏移量（通常是无符号整数） |
| 变址寻址       | $EA=A+(R)$，指令地址字段引用一个主存地址，被引用的寄存器含有相对于该地址的一个偏移量                   |

#### 栈寻址

栈指针保存在寄存器中，对寄存器中栈位置的访问实际上是一种寄存器间接寻址方式

### 指令周期

取指、译指、执行、（中断）

### 冒险

1. 数据冒险：未生成指令所需要的数据，可以暂停指令进行、进行转发、改变指令顺序
2. 控制冒险：指令执行的顺序被更改，可以**预测是否会发生跳转**
3. 结构冒险：已进入流水线的不同指令在同一时刻访问相同的硬件资源，比如同时访问内存，可以使用多个硬件资源，或者分时使用

### 控制器

**微操作：**每个子周期由一系列涉及CPU寄存器操作的更小步骤组成，称为微操作

取指周期、间址周期、执行周期、中断周期

#### 硬布线实现

1. 对于标志和控制总线信号，每位都有特定含义
2. 对于指令寄存器，译码，使每一个操作码有一个唯一的逻辑输入
3. 时钟，使用一个定时器作为输入，同时在指令周期结束时必须通知定时器重新计数

#### 微程序实现

![image-20241202213707142](C:\Users\ocl\AppData\Roaming\Typora\typora-user-images\image-20241202213707142.png)

1. 定序，根据当前的微指令、条件标志和指令寄存器的内容，产生下一微指令的控制存储器地址
   1. 双地址字段，每条微指令提供两个地址字段，选择并发送其中某个到控制地址寄存器
   2. 单地址字段
   3. 可变格式，多一位用于指定哪种格式被使用
2. 构成：定序逻辑、控制地址寄存器（含有即将被读出的微指令地址）、控制存储器（存放微指令）、控制缓冲寄存器（存放被读出的微指令）
3. 工作流程
   1. 定序逻辑发出读命令给控制存储器
   2. 读出微指令后存放到控制缓冲寄存器
   3. 生成控制型号，并根据定序逻辑提供下一条地址信息
   4. 将新的地址装入控制地址寄存器

## 总线

**仲裁：**当多个设备需要和总线通信时，通过某种策略选择一个设备

> 优先级越高，设备越优先；优先级最低的设备不能一直被延迟

1. 链式查询，允许较高优先级的设备下放控制信号
2. 计数器查询，把总线允许线替换为设备ID线。如果总线空闲，总线仲裁器通过设备ID线发送计数；如果发送请求的设备ID等于裁决器当前ID，则停止计数并设置为繁忙
3. 独立请求，每个设备都有自己的总线请求线和允许线，由仲裁器调度。LRU、FIFO等
4. 自举式，固定优先级，每个设备都有总线请求线，自行判断是否在请求总线的设备中优先级最高
5. 冲突检测，检查总线是否繁忙。如果同时有多个设备发现总线空闲，可能会产生冲突。如果发生冲突，所有使用总线的设备停止数据传输，并分别在随机间隔时间后再次请求

### 时序

1. 同步时序，事件发生由时钟决定
2. 异步时序，一个事件的发生取决于前一个事件的发生
3. 半同步，同步、异步结合
4. 分离事务，设备准备数据期间释放总线，把一个事件分离为多个过程

### 总线带宽和数据传输速率

总线带宽：总线的最大数据传输速率

数据传输速率：考虑地址传输、握手等因素

总线宽度：组成总线的线数

**总线层级结构：**

1. 单总线
2. 双总线，I/O总线
3. 多总线，I/O总线等

## I/O模块

连接外设、计算机内部系统之间的桥梁，通过系统总线和存储器连接，通过专用数据线和外设连接。

### 编程式I/O

处理器发送一条I/O命令直到I/O模块执行结束后才继续工作

**I/O命令：**执行I/O操作时处理器发送一个指定具体I/O模块和外设的地址

### 中断驱动式I/O

**响应优先级**（是否可以打断）、**处理优先级**（先后处理顺序，不可打断）

> 如果是单级中断系统，系统在执行中断前会**关中断**，此时无法响应中断，当前中断执行结束后会**开中断**

### DMA(直接存储器读取)

处理器向DMA发送命令后，DMA直接访问主存，传输完成后向处理器发送中断

**内存访问的方法**：

1. CPU停止法，DMA访问主存时cpu不访问主存
2. 周期窃取，DMA和CPU周期性交替访问主存
3. 交替分时访问，将内存时间分成等时，同一时段内CPU和DMA分别访问
